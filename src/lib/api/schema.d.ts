/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
	"/health": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Health Check
		 * @description Comprehensive health check endpoint.
		 *
		 *     Performs health checks on all critical components:
		 *     - Database
		 *     - Redis
		 *     - LLM Providers
		 *     - Destinations
		 *     - Storage
		 *     - OpenTelemetry
		 *     - Vector Store
		 *
		 *     Returns:
		 *         Comprehensive health status of all components
		 */
		get: operations["health_check_health_get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/health/ready": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Readiness Probe
		 * @description Kubernetes readiness probe.
		 *
		 *     Checks if the service is ready to receive traffic.
		 *     This should return success when all required dependencies are available.
		 *
		 *     Returns:
		 *         Readiness status
		 */
		get: operations["readiness_probe_health_ready_get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/health/live": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Liveness Probe
		 * @description Kubernetes liveness probe.
		 *
		 *     Checks if the service is alive and should not be restarted.
		 *     This is a lightweight check that just verifies the process is running.
		 *
		 *     Returns:
		 *         Liveness status
		 */
		get: operations["liveness_probe_health_live_get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/health/queue": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Get Queue Health
		 * @description Queue health and status.
		 */
		get: operations["get_queue_health_health_queue_get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/metrics": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Get Metrics
		 * @description Prometheus metrics endpoint.
		 */
		get: operations["get_metrics_metrics_get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/openapi.yaml": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Get Openapi Yaml
		 * @description Get OpenAPI specification as YAML.
		 */
		get: operations["get_openapi_yaml_api_v1_openapi_yaml_get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/jobs": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * List Jobs
		 * @description List jobs with filtering.
		 */
		get: operations["list_jobs_api_v1_jobs_get"];
		put?: never;
		/**
		 * Create Job
		 * @description Submit a new ingestion job.
		 */
		post: operations["create_job_api_v1_jobs_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/jobs/{job_id}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Get Job
		 * @description Get job details.
		 */
		get: operations["get_job_api_v1_jobs__job_id__get"];
		put?: never;
		post?: never;
		/**
		 * Cancel Job
		 * @description Cancel a job.
		 */
		delete: operations["cancel_job_api_v1_jobs__job_id__delete"];
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/jobs/{job_id}/retry": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Retry Job
		 * @description Retry a failed job.
		 */
		post: operations["retry_job_api_v1_jobs__job_id__retry_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/jobs/{job_id}/result": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Get Job Result
		 * @description Get job processing result.
		 */
		get: operations["get_job_result_api_v1_jobs__job_id__result_get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/upload": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Upload Files
		 * @description Upload file(s) for processing.
		 */
		post: operations["upload_files_api_v1_upload_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/upload/url": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Ingest From Url
		 * @description Ingest from URL.
		 */
		post: operations["ingest_from_url_api_v1_upload_url_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/pipelines": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * List Pipelines
		 * @description List pipeline configurations.
		 */
		get: operations["list_pipelines_api_v1_pipelines_get"];
		put?: never;
		/**
		 * Create Pipeline
		 * @description Create pipeline configuration.
		 */
		post: operations["create_pipeline_api_v1_pipelines_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/pipelines/{pipeline_id}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Get Pipeline
		 * @description Get pipeline configuration.
		 */
		get: operations["get_pipeline_api_v1_pipelines__pipeline_id__get"];
		/**
		 * Update Pipeline
		 * @description Update pipeline configuration.
		 */
		put: operations["update_pipeline_api_v1_pipelines__pipeline_id__put"];
		post?: never;
		/**
		 * Delete Pipeline
		 * @description Delete pipeline configuration.
		 */
		delete: operations["delete_pipeline_api_v1_pipelines__pipeline_id__delete"];
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/sources": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * List Sources
		 * @description List source plugins.
		 */
		get: operations["list_sources_api_v1_sources_get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/destinations": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * List Destinations
		 * @description List destination plugins.
		 */
		get: operations["list_destinations_api_v1_destinations_get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/auth/login": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Login
		 * @description Login and get JWT token.
		 */
		post: operations["login_api_v1_auth_login_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/auth/refresh": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Refresh Token
		 * @description Refresh access token.
		 */
		post: operations["refresh_token_api_v1_auth_refresh_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/auth/api-keys": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * List Api Keys
		 * @description List API keys.
		 */
		get: operations["list_api_keys_api_v1_auth_api_keys_get"];
		put?: never;
		/**
		 * Create Api Key
		 * @description Create a new API key.
		 */
		post: operations["create_api_key_api_v1_auth_api_keys_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/auth/api-keys/{key_id}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		post?: never;
		/**
		 * Revoke Api Key
		 * @description Revoke an API key.
		 */
		delete: operations["revoke_api_key_api_v1_auth_api_keys__key_id__delete"];
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/webhooks": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * List Webhooks
		 * @description List webhook subscriptions.
		 */
		get: operations["list_webhooks_api_v1_webhooks_get"];
		put?: never;
		/**
		 * Create Webhook
		 * @description Create a webhook subscription.
		 */
		post: operations["create_webhook_api_v1_webhooks_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/webhooks/{webhook_id}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		post?: never;
		/**
		 * Delete Webhook
		 * @description Delete a webhook subscription.
		 */
		delete: operations["delete_webhook_api_v1_webhooks__webhook_id__delete"];
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/webhooks/{webhook_id}/deliveries": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * List Webhook Deliveries
		 * @description List webhook deliveries for a subscription.
		 */
		get: operations["list_webhook_deliveries_api_v1_webhooks__webhook_id__deliveries_get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/audit/logs": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Query Audit Logs
		 * @description Query audit logs.
		 */
		get: operations["query_audit_logs_api_v1_audit_logs_get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/health/vector": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Vector Store Health
		 * @description Vector store health check endpoint.
		 *
		 *     Checks the availability of PostgreSQL extensions required for vector storage:
		 *     - pgvector: For vector similarity search
		 *     - pg_trgm: For trigram-based text search
		 *
		 *     Returns:
		 *         Vector store health status with extension version information
		 */
		get: operations["vector_store_health_health_vector_get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/health/detailed/{component}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Detailed Component Health
		 * @description Get detailed health information for a specific component.
		 *
		 *     Args:
		 *         component: Component name to check
		 *
		 *     Returns:
		 *         Detailed health information
		 *
		 *     Raises:
		 *         HTTPException: If component not found
		 */
		get: operations["detailed_component_health_health_detailed__component__get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/jobs/{job_id}/chunks": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * List chunks for a job
		 * @description Retrieve paginated list of document chunks for a specific job. Embeddings are excluded by default for performance.
		 */
		get: operations["list_chunks_api_v1_jobs__job_id__chunks_get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/jobs/{job_id}/chunks/{chunk_id}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Get a specific chunk
		 * @description Retrieve a single document chunk by ID with optional embedding data.
		 */
		get: operations["get_chunk_api_v1_jobs__job_id__chunks__chunk_id__get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/search/semantic": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Semantic search by embedding
		 * @description Search for similar chunks using a pre-computed embedding vector with cosine similarity.
		 */
		post: operations["semantic_search_api_v1_search_semantic_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/search/text": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Text search
		 * @description Search for chunks using full-text search with BM25 ranking and optional fuzzy matching.
		 */
		post: operations["text_search_api_v1_search_text_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/search/hybrid": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Hybrid search
		 * @description Combine vector similarity and text search using weighted sum or RRF fusion.
		 */
		post: operations["hybrid_search_api_v1_search_hybrid_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/search/similar/{chunk_id}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Find similar chunks
		 * @description Find chunks semantically similar to a reference chunk using its embedding.
		 */
		get: operations["find_similar_chunks_api_v1_search_similar__chunk_id__get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/rag/query": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Execute RAG query
		 * @description Execute a Retrieval-Augmented Generation query with the specified strategy.
		 *
		 *         The endpoint:
		 *         1. Classifies the query type (factual, analytical, comparative, vague, multi_hop)
		 *         2. Selects optimal strategies based on query type and preset
		 *         3. Rewrites the query for better retrieval
		 *         4. Retrieves relevant documents
		 *         5. Re-ranks results (if enabled)
		 *         6. Evaluates quality and self-corrects if needed
		 *         7. Generates the final answer with source attribution
		 *
		 *         **Strategy Presets:**
		 *         - `auto`: Automatically selects strategies based on query classification
		 *         - `fast`: Prioritizes speed (query_rewrite + hybrid_search only)
		 *         - `balanced`: Balanced approach with reranking (default)
		 *         - `thorough`: Maximum quality with HyDE and all optimizations
		 */
		post: operations["rag_query_api_v1_rag_query_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/rag/strategies": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * List available RAG strategies
		 * @description Get information about all available RAG strategy presets.
		 *
		 *         Returns details about each strategy including:
		 *         - Configuration settings (query_rewrite, hyde, reranking, hybrid_search)
		 *         - Recommended use cases
		 *         - Estimated latency
		 */
		get: operations["list_strategies_api_v1_rag_strategies_get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/rag/strategies/{name}/evaluate": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Evaluate a RAG strategy
		 * @description Evaluate a specific RAG strategy against a test query with optional ground truth.
		 *
		 *         This endpoint is useful for:
		 *         - Comparing strategy performance on specific query types
		 *         - Validating strategy configurations
		 *         - Benchmarking before production deployment
		 *
		 *         Provide ground_truth_relevant_ids and ground_truth_answer for comprehensive evaluation
		 *         including both retrieval and generation metrics.
		 */
		post: operations["evaluate_strategy_api_v1_rag_strategies__name__evaluate_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/rag/metrics": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Get RAG system metrics
		 * @description Retrieve current metrics for the RAG system.
		 *
		 *         Returns:
		 *         - Summary statistics (total queries, average latency, quality scores)
		 *         - Component health status
		 *         - Recent evaluation alerts
		 *         - Performance trends
		 *
		 *         Note: This endpoint returns real-time metrics. For historical data,
		 *         use the audit logs or monitoring dashboards.
		 */
		get: operations["get_metrics_api_v1_rag_metrics_get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/rag/evaluate": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Run benchmark evaluation
		 * @description Run a benchmark evaluation of the RAG system against a standard dataset.
		 *
		 *         This endpoint is useful for:
		 *         - Assessing overall RAG system quality
		 *         - Comparing strategy performance
		 *         - Regression testing
		 *         - Capacity planning
		 *
		 *         **Benchmarks:**
		 *         - `ms_marco`: Microsoft MARCO dataset (if available)
		 *         - `custom_qa`: Custom question-answer pairs (if configured)
		 *
		 *         Note: Benchmark runs can take several minutes depending on max_queries.
		 *         Consider using async processing for large benchmarks.
		 */
		post: operations["run_benchmark_api_v1_rag_evaluate_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
}
export type webhooks = Record<string, never>;
export interface components {
	schemas: {
		/**
		 * ChunkJobMismatchResponse
		 * @description Error response when chunk doesn't belong to job.
		 */
		ChunkJobMismatchResponse: {
			/**
			 * Detail
			 * @default Chunk does not belong to the specified job
			 */
			detail: string;
		};
		/**
		 * ComponentHealth
		 * @description Health status of a system component.
		 */
		ComponentHealth: {
			status: components["schemas"]["HealthStatus"];
			/** Latency Ms */
			latency_ms?: number | null;
			/** Message */
			message?: string | null;
		};
		/**
		 * ComprehensiveHealthResponse
		 * @description Comprehensive health check response.
		 */
		ComprehensiveHealthResponse: {
			status: components["schemas"]["HealthStatus"];
			/** Timestamp */
			timestamp: string;
			/** Version */
			version: string;
			/** Environment */
			environment: string;
			/** Components */
			components: {
				[key: string]: components["schemas"]["ComponentHealth"];
			};
			/** Overall Healthy */
			overall_healthy: boolean;
		};
		/**
		 * DocumentChunkListItem
		 * @description List item response for document chunks (excludes embedding by default).
		 *
		 *     Used in list endpoints where embedding data is excluded for performance.
		 */
		DocumentChunkListItem: {
			/**
			 * Id
			 * Format: uuid
			 * @description Unique chunk identifier
			 */
			id: string;
			/**
			 * Job Id
			 * Format: uuid
			 * @description Parent job identifier
			 */
			job_id: string;
			/**
			 * Chunk Index
			 * @description Position within document (0-indexed)
			 */
			chunk_index: number;
			/**
			 * Content
			 * @description Text content of the chunk
			 */
			content: string;
			/**
			 * Content Hash
			 * @description SHA-256 hash for deduplication
			 */
			content_hash?: string | null;
			/**
			 * Metadata
			 * @description Chunk metadata (page numbers, etc.)
			 */
			metadata?: {
				[key: string]: unknown;
			};
			/**
			 * Created At
			 * Format: date-time
			 * @description Timestamp of record creation
			 */
			created_at: string;
		};
		/**
		 * DocumentChunkListResponse
		 * @description Response model for paginated chunk list.
		 */
		DocumentChunkListResponse: {
			/**
			 * Items
			 * @description List of chunks
			 */
			items?: components["schemas"]["DocumentChunkListItem"][];
			/**
			 * Total
			 * @description Total number of chunks for this job
			 */
			total: number;
			/**
			 * Limit
			 * @description Number of items returned
			 */
			limit: number;
			/**
			 * Offset
			 * @description Offset from start of results
			 */
			offset: number;
		};
		/**
		 * DocumentChunkResponse
		 * @description Response model for a single document chunk.
		 *
		 *     Used for both list items and detailed responses. The embedding field
		 *     is only included when explicitly requested via include_embedding parameter.
		 */
		DocumentChunkResponse: {
			/**
			 * Id
			 * Format: uuid
			 * @description Unique chunk identifier
			 */
			id: string;
			/**
			 * Job Id
			 * Format: uuid
			 * @description Parent job identifier
			 */
			job_id: string;
			/**
			 * Chunk Index
			 * @description Position within document (0-indexed)
			 */
			chunk_index: number;
			/**
			 * Content
			 * @description Text content of the chunk
			 */
			content: string;
			/**
			 * Content Hash
			 * @description SHA-256 hash for deduplication
			 */
			content_hash?: string | null;
			/**
			 * Embedding
			 * @description Vector embedding for semantic search (only when requested)
			 */
			embedding?: number[] | null;
			/**
			 * Metadata
			 * @description Chunk metadata (page numbers, etc.)
			 */
			metadata?: {
				[key: string]: unknown;
			};
			/**
			 * Created At
			 * Format: date-time
			 * @description Timestamp of record creation
			 */
			created_at: string;
		};
		/** HTTPValidationError */
		HTTPValidationError: {
			/** Detail */
			detail?: components["schemas"]["ValidationError"][];
		};
		/**
		 * HealthStatus
		 * @description Component health status.
		 * @enum {string}
		 */
		HealthStatus: "healthy" | "degraded" | "unhealthy";
		/**
		 * HybridSearchRequest
		 * @description Request body for hybrid search.
		 *
		 *     Combines vector similarity search and text search using configurable fusion methods
		 *     (weighted sum or reciprocal rank fusion).
		 * @example {
		 *       "filters": {},
		 *       "fusion_method": "weighted_sum",
		 *       "min_similarity": 0.5,
		 *       "query": "neural network architecture",
		 *       "text_weight": 0.3,
		 *       "top_k": 10,
		 *       "vector_weight": 0.7
		 *     }
		 */
		HybridSearchRequest: {
			/**
			 * Query
			 * @description Search query text
			 */
			query: string;
			/**
			 * Top K
			 * @description Maximum number of results to return
			 * @default 10
			 */
			top_k: number;
			/**
			 * Vector Weight
			 * @description Weight for vector search scores
			 * @default 0.7
			 */
			vector_weight: number;
			/**
			 * Text Weight
			 * @description Weight for text search scores
			 * @default 0.3
			 */
			text_weight: number;
			/**
			 * Fusion Method
			 * @description Fusion method: 'weighted_sum' or 'rrf' (reciprocal rank fusion)
			 * @default weighted_sum
			 */
			fusion_method: string;
			/**
			 * Min Similarity
			 * @description Minimum similarity threshold for vector search
			 * @default 0.5
			 */
			min_similarity: number;
			/**
			 * Filters
			 * @description Optional filters (e.g., job_id)
			 */
			filters?: {
				[key: string]: unknown;
			};
		};
		/**
		 * HybridSearchResultItem
		 * @description Hybrid search result with component scores.
		 * @example {
		 *       "chunk_id": "123e4567-e89b-12d3-a456-426614174000",
		 *       "chunk_index": 0,
		 *       "content": "Sample chunk content...",
		 *       "fusion_method": "weighted_sum",
		 *       "hybrid_score": 0.88,
		 *       "job_id": "123e4567-e89b-12d3-a456-426614174001",
		 *       "metadata": {
		 *         "page": 1
		 *       },
		 *       "rank": 1,
		 *       "text_rank": 2,
		 *       "text_score": 0.78,
		 *       "vector_rank": 1,
		 *       "vector_score": 0.92
		 *     }
		 */
		HybridSearchResultItem: {
			/**
			 * Chunk Id
			 * @description Unique chunk identifier
			 */
			chunk_id: string;
			/**
			 * Job Id
			 * @description Parent job identifier
			 */
			job_id: string;
			/**
			 * Chunk Index
			 * @description Position within document
			 */
			chunk_index: number;
			/**
			 * Content
			 * @description Text content of the chunk
			 */
			content: string;
			/**
			 * Metadata
			 * @description Chunk metadata
			 */
			metadata?: {
				[key: string]: unknown;
			};
			/**
			 * Hybrid Score
			 * @description Combined hybrid score (0-1)
			 */
			hybrid_score: number;
			/**
			 * Vector Score
			 * @description Vector similarity score (0-1) if available
			 */
			vector_score?: number | null;
			/**
			 * Text Score
			 * @description Text search score (0-1) if available
			 */
			text_score?: number | null;
			/**
			 * Vector Rank
			 * @description Rank in vector search results
			 */
			vector_rank?: number | null;
			/**
			 * Text Rank
			 * @description Rank in text search results
			 */
			text_rank?: number | null;
			/**
			 * Rank
			 * @description Final rank (1-based)
			 */
			rank: number;
			/**
			 * Fusion Method
			 * @description Fusion method used
			 */
			fusion_method: string;
		};
		/**
		 * HybridSearchResultsResponse
		 * @description Response model for hybrid search results.
		 */
		HybridSearchResultsResponse: {
			/**
			 * Results
			 * @description Search results
			 */
			results?: components["schemas"]["HybridSearchResultItem"][];
			/**
			 * Total
			 * @description Total number of results
			 */
			total: number;
			/**
			 * Query Time Ms
			 * @description Query execution time in milliseconds
			 */
			query_time_ms: number;
		};
		/**
		 * InvalidEmbeddingResponse
		 * @description Error response for invalid embedding.
		 */
		InvalidEmbeddingResponse: {
			/**
			 * Detail
			 * @default Invalid embedding vector
			 */
			detail: string;
		};
		/**
		 * InvalidQueryResponse
		 * @description Error response for invalid query.
		 */
		InvalidQueryResponse: {
			/**
			 * Detail
			 * @default Invalid search query
			 */
			detail: string;
		};
		/**
		 * JobNotFoundResponse
		 * @description Error response when job is not found.
		 */
		JobNotFoundResponse: {
			/**
			 * Detail
			 * @default Job not found
			 */
			detail: string;
		};
		/**
		 * LivenessResponse
		 * @description Kubernetes liveness probe response.
		 */
		LivenessResponse: {
			/** Alive */
			alive: boolean;
			/** Timestamp */
			timestamp: string;
		};
		/**
		 * QueryType
		 * @description Query classification types for RAG strategy selection.
		 *
		 *     This enum defines the different types of queries that can be classified
		 *     to determine the optimal RAG retrieval strategy.
		 *
		 *     Attributes:
		 *         FACTUAL: Simple fact lookup (e.g., "What is X?", "Who is Y?")
		 *         ANALYTICAL: Requires explanation or synthesis (e.g., "Explain X", "How does Y work?")
		 *         COMPARATIVE: Compares multiple items (e.g., "Compare X and Y", "Pros/cons")
		 *         VAGUE: Unclear or broad queries (e.g., "Tell me about...", "Information on...")
		 *         MULTI_HOP: Requires multiple retrieval steps (e.g., "Author of X on topic Y")
		 * @enum {string}
		 */
		QueryType: "factual" | "analytical" | "comparative" | "vague" | "multi_hop";
		/**
		 * RAGBenchmarkRequest
		 * @description Request model for running benchmark evaluation.
		 *
		 *     Attributes:
		 *         benchmark_name: Name of the benchmark dataset (e.g., ms_marco, custom_qa)
		 *         max_queries: Maximum number of queries to evaluate
		 *         k_values: K values for retrieval metrics
		 *         strategy_preset: Strategy preset to evaluate
		 * @example {
		 *       "benchmark_name": "ms_marco",
		 *       "k_values": [
		 *         5,
		 *         10
		 *       ],
		 *       "max_queries": 100,
		 *       "strategy_preset": "balanced"
		 *     }
		 */
		RAGBenchmarkRequest: {
			/**
			 * Benchmark Name
			 * @description Name of benchmark dataset (ms_marco, custom_qa, etc.)
			 */
			benchmark_name: string;
			/**
			 * Max Queries
			 * @description Maximum number of queries to evaluate
			 * @default 100
			 */
			max_queries: number;
			/**
			 * K Values
			 * @description K values for retrieval metrics
			 */
			k_values?: number[];
			/**
			 * Strategy Preset
			 * @description Strategy preset to evaluate
			 * @default balanced
			 */
			strategy_preset: string;
		};
		/**
		 * RAGBenchmarkResponse
		 * @description Response model for benchmark evaluation.
		 *
		 *     Attributes:
		 *         benchmark_name: Name of the benchmark
		 *         strategy_preset: Strategy preset evaluated
		 *         aggregate_metrics: Aggregated metrics across all queries
		 *         per_query_results: Individual results for each query
		 *         total_queries: Total number of queries processed
		 *         successful_queries: Number of successfully processed queries
		 *         failed_queries: Number of failed queries
		 *         total_latency_ms: Total time for benchmark run
		 *         started_at: When benchmark started
		 *         completed_at: When benchmark completed
		 */
		RAGBenchmarkResponse: {
			/**
			 * Benchmark Name
			 * @description Name of the benchmark
			 */
			benchmark_name: string;
			/**
			 * Strategy Preset
			 * @description Strategy preset evaluated
			 */
			strategy_preset: string;
			/**
			 * Aggregate Metrics
			 * @description Aggregated metrics across all queries
			 */
			aggregate_metrics: {
				[key: string]: number;
			};
			/**
			 * Per Query Results
			 * @description Individual results
			 */
			per_query_results?: {
				[key: string]: unknown;
			}[];
			/**
			 * Total Queries
			 * @description Total number of queries processed
			 */
			total_queries: number;
			/**
			 * Successful Queries
			 * @description Number of successfully processed queries
			 */
			successful_queries: number;
			/**
			 * Failed Queries
			 * @description Number of failed queries
			 */
			failed_queries: number;
			/**
			 * Total Latency Ms
			 * @description Total time for benchmark run
			 */
			total_latency_ms: number;
			/**
			 * Started At
			 * Format: date-time
			 * @description When benchmark started
			 */
			started_at: string;
			/**
			 * Completed At
			 * @description When benchmark completed
			 */
			completed_at?: string | null;
		};
		/**
		 * RAGMetrics
		 * @description Metrics for RAG pipeline execution.
		 *
		 *     Tracks performance and quality metrics for a RAG query execution,
		 *     useful for monitoring, optimization, and debugging.
		 *
		 *     Attributes:
		 *         latency_ms: Total query processing time in milliseconds
		 *         tokens_used: Total tokens consumed by LLM calls
		 *         retrieval_score: Average relevance score of retrieved chunks
		 *         classification_confidence: Confidence score of query classification
		 *         rewrite_time_ms: Time spent on query rewriting
		 *         retrieval_time_ms: Time spent on document retrieval
		 *         reranking_time_ms: Time spent on re-ranking (if enabled)
		 *         generation_time_ms: Time spent on answer generation
		 *         chunks_retrieved: Number of chunks retrieved
		 *         chunks_used: Number of chunks used in final answer
		 *         self_correction_iterations: Number of self-correction iterations
		 * @example {
		 *       "chunks_retrieved": 20,
		 *       "chunks_used": 5,
		 *       "classification_confidence": 0.95,
		 *       "generation_time_ms": 44.8,
		 *       "latency_ms": 245.5,
		 *       "reranking_time_ms": 35.5,
		 *       "retrieval_score": 0.82,
		 *       "retrieval_time_ms": 120,
		 *       "rewrite_time_ms": 45.2,
		 *       "self_correction_iterations": 0,
		 *       "tokens_used": 850
		 *     }
		 */
		RAGMetrics: {
			/**
			 * Latency Ms
			 * @description Total query processing time in milliseconds
			 */
			latency_ms: number;
			/**
			 * Tokens Used
			 * @description Total tokens consumed by LLM calls
			 * @default 0
			 */
			tokens_used: number;
			/**
			 * Retrieval Score
			 * @description Average relevance score of retrieved chunks
			 */
			retrieval_score: number;
			/**
			 * Classification Confidence
			 * @description Confidence score of query classification
			 */
			classification_confidence: number;
			/**
			 * Rewrite Time Ms
			 * @description Time spent on query rewriting
			 * @default 0
			 */
			rewrite_time_ms: number;
			/**
			 * Retrieval Time Ms
			 * @description Time spent on document retrieval
			 * @default 0
			 */
			retrieval_time_ms: number;
			/**
			 * Reranking Time Ms
			 * @description Time spent on re-ranking (if enabled)
			 * @default 0
			 */
			reranking_time_ms: number;
			/**
			 * Generation Time Ms
			 * @description Time spent on answer generation
			 * @default 0
			 */
			generation_time_ms: number;
			/**
			 * Chunks Retrieved
			 * @description Number of chunks retrieved
			 * @default 0
			 */
			chunks_retrieved: number;
			/**
			 * Chunks Used
			 * @description Number of chunks used in final answer
			 * @default 0
			 */
			chunks_used: number;
			/**
			 * Self Correction Iterations
			 * @description Number of self-correction iterations
			 * @default 0
			 */
			self_correction_iterations: number;
		};
		/**
		 * RAGMetricsResponse
		 * @description Response model for RAG metrics endpoint.
		 *
		 *     Attributes:
		 *         summary: Summary metrics
		 *         component_health: Health status of RAG components
		 *         recent_alerts: Recent evaluation alerts
		 *         performance_trends: Performance trend data
		 */
		RAGMetricsResponse: {
			/** @description Summary metrics */
			summary: components["schemas"]["RAGMetricsSummary"];
			/**
			 * Component Health
			 * @description Health status of RAG components
			 */
			component_health?: {
				[key: string]: unknown;
			};
			/**
			 * Recent Alerts
			 * @description Recent evaluation alerts
			 */
			recent_alerts?: {
				[key: string]: unknown;
			}[];
			/**
			 * Performance Trends
			 * @description Performance trend data
			 */
			performance_trends?: {
				[key: string]: unknown;
			};
		};
		/**
		 * RAGMetricsSummary
		 * @description Summary of RAG system metrics.
		 *
		 *     Attributes:
		 *         total_queries: Total number of queries processed
		 *         avg_latency_ms: Average query latency
		 *         avg_retrieval_score: Average retrieval quality score
		 *         strategy_usage: Usage count per strategy
		 *         query_type_distribution: Distribution of query types
		 *         timestamp: When metrics were collected
		 */
		RAGMetricsSummary: {
			/**
			 * Total Queries
			 * @description Total number of queries processed
			 * @default 0
			 */
			total_queries: number;
			/**
			 * Avg Latency Ms
			 * @description Average query latency
			 * @default 0
			 */
			avg_latency_ms: number;
			/**
			 * Avg Retrieval Score
			 * @description Average retrieval quality score
			 * @default 0
			 */
			avg_retrieval_score: number;
			/**
			 * Avg Classification Confidence
			 * @description Average classification confidence
			 * @default 0
			 */
			avg_classification_confidence: number;
			/**
			 * Strategy Usage
			 * @description Usage count per strategy
			 */
			strategy_usage?: {
				[key: string]: number;
			};
			/**
			 * Query Type Distribution
			 * @description Distribution of query types
			 */
			query_type_distribution?: {
				[key: string]: number;
			};
			/**
			 * Timestamp
			 * Format: date-time
			 * @description When metrics were collected
			 */
			timestamp?: string;
		};
		/**
		 * RAGQueryErrorResponse
		 * @description Error response for RAG query endpoint.
		 */
		RAGQueryErrorResponse: {
			/**
			 * Error
			 * @description Error details
			 */
			error: {
				[key: string]: unknown;
			};
			/**
			 * Query Id
			 * @description Query ID if available
			 */
			query_id?: string | null;
		};
		/**
		 * RAGQueryRequest
		 * @description Request model for RAG query endpoint.
		 *
		 *     Attributes:
		 *         query: The user's natural language query
		 *         strategy: Strategy preset to use (auto, fast, balanced, thorough)
		 *         context: Optional conversation context for follow-up queries
		 *         filters: Optional metadata filters for document retrieval
		 *         top_k: Number of sources to retrieve (default: 5)
		 * @example {
		 *       "context": {
		 *         "previous_queries": [
		 *           "Tell me about programming trends"
		 *         ],
		 *         "session_id": "session_123"
		 *       },
		 *       "filters": {
		 *         "source_type": "documentation"
		 *       },
		 *       "query": "What is vibe coding and what are its pros and cons?",
		 *       "strategy": "balanced",
		 *       "top_k": 5
		 *     }
		 */
		RAGQueryRequest: {
			/**
			 * Query
			 * @description The user's natural language query
			 */
			query: string;
			/**
			 * Strategy
			 * @description Strategy preset: auto, fast, balanced, or thorough
			 * @default auto
			 */
			strategy: string;
			/**
			 * Context
			 * @description Optional conversation context with previous_queries, previous_responses, session_id
			 */
			context?: {
				[key: string]: unknown;
			} | null;
			/**
			 * Filters
			 * @description Optional metadata filters for document retrieval
			 */
			filters?: {
				[key: string]: unknown;
			};
			/**
			 * Top K
			 * @description Number of sources to retrieve
			 * @default 5
			 */
			top_k: number;
		};
		/**
		 * RAGQueryResponse
		 * @description Response model for RAG query endpoint.
		 *
		 *     Attributes:
		 *         answer: Generated answer text
		 *         sources: List of source documents used
		 *         metrics: Execution metrics
		 *         strategy_used: Strategy preset used for this query
		 *         query_type: Type of query classified
		 *         query_id: Unique identifier for this query
		 * @example {
		 *       "answer": "Vibe coding is a programming approach that emphasizes...",
		 *       "metrics": {
		 *         "chunks_retrieved": 20,
		 *         "chunks_used": 5,
		 *         "classification_confidence": 0.95,
		 *         "generation_time_ms": 44.8,
		 *         "latency_ms": 245.5,
		 *         "reranking_time_ms": 35.5,
		 *         "retrieval_score": 0.82,
		 *         "retrieval_time_ms": 120,
		 *         "rewrite_time_ms": 45.2,
		 *         "self_correction_iterations": 0,
		 *         "tokens_used": 850
		 *       },
		 *       "query_id": "rag_query_123",
		 *       "query_type": "factual",
		 *       "sources": [
		 *         {
		 *           "chunk_id": "550e8400-e29b-41d4-a716-446655440000",
		 *           "content": "Vibe coding is a programming approach...",
		 *           "metadata": {
		 *             "page": 3,
		 *             "source": "doc1.pdf"
		 *           },
		 *           "score": 0.92
		 *         }
		 *       ],
		 *       "strategy_used": "balanced"
		 *     }
		 */
		RAGQueryResponse: {
			/**
			 * Answer
			 * @description Generated answer text
			 */
			answer: string;
			/**
			 * Sources
			 * @description List of source documents used
			 */
			sources?: components["schemas"]["RAGSource"][];
			/** @description Execution metrics */
			metrics: components["schemas"]["RAGMetrics"];
			/**
			 * Strategy Used
			 * @description Strategy preset used for this query
			 */
			strategy_used: string;
			/** @description Type of query classified */
			query_type: components["schemas"]["QueryType"];
			/**
			 * Query Id
			 * @description Unique identifier for this query
			 */
			query_id: string;
		};
		/**
		 * RAGSource
		 * @description Source document in RAG response.
		 *
		 *     Attributes:
		 *         chunk_id: Unique identifier of the source chunk
		 *         content: Text content from the source
		 *         score: Relevance score (0-1)
		 *         metadata: Additional metadata about the source
		 */
		RAGSource: {
			/**
			 * Chunk Id
			 * @description Unique identifier of the source chunk
			 */
			chunk_id: string;
			/**
			 * Content
			 * @description Text content from the source
			 */
			content: string;
			/**
			 * Score
			 * @description Relevance score (0-1)
			 */
			score: number;
			/**
			 * Metadata
			 * @description Additional metadata
			 */
			metadata?: {
				[key: string]: unknown;
			};
		};
		/**
		 * RAGStrategiesResponse
		 * @description Response model listing available RAG strategies.
		 *
		 *     Attributes:
		 *         strategies: List of available strategies
		 *         default_strategy: Default strategy name
		 *         total_count: Total number of strategies
		 */
		RAGStrategiesResponse: {
			/**
			 * Strategies
			 * @description List of available strategies
			 */
			strategies: components["schemas"]["RAGStrategyInfo"][];
			/**
			 * Default Strategy
			 * @description Default strategy name
			 * @default balanced
			 */
			default_strategy: string;
			/**
			 * Total Count
			 * @description Total number of strategies
			 */
			total_count: number;
		};
		/**
		 * RAGStrategyEvaluateRequest
		 * @description Request model for evaluating a specific RAG strategy.
		 *
		 *     Attributes:
		 *         query: The test query to evaluate
		 *         ground_truth_relevant_ids: List of expected relevant chunk IDs
		 *         ground_truth_answer: Expected answer text (optional)
		 *         iterations: Number of iterations to run for averaging
		 * @example {
		 *       "ground_truth_answer": "Machine learning is a subset of AI...",
		 *       "ground_truth_relevant_ids": [
		 *         "chunk_1",
		 *         "chunk_2"
		 *       ],
		 *       "iterations": 3,
		 *       "query": "What is machine learning?"
		 *     }
		 */
		RAGStrategyEvaluateRequest: {
			/**
			 * Query
			 * @description The test query to evaluate
			 */
			query: string;
			/**
			 * Ground Truth Relevant Ids
			 * @description List of expected relevant chunk IDs
			 */
			ground_truth_relevant_ids?: string[];
			/**
			 * Ground Truth Answer
			 * @description Expected answer text for generation evaluation
			 */
			ground_truth_answer?: string | null;
			/**
			 * Iterations
			 * @description Number of iterations to run for averaging
			 * @default 1
			 */
			iterations: number;
			/**
			 * Context
			 * @description Optional conversation context
			 */
			context?: {
				[key: string]: unknown;
			} | null;
		};
		/**
		 * RAGStrategyEvaluateResponse
		 * @description Response model for strategy evaluation.
		 *
		 *     Attributes:
		 *         strategy_name: Name of the evaluated strategy
		 *         query: The test query used
		 *         retrieval_metrics: Retrieval quality metrics
		 *         generation_metrics: Generation quality metrics (if ground truth provided)
		 *         latency_ms: Total evaluation time
		 *         query_type: Classified query type
		 *         per_iteration_results: Results from each iteration
		 */
		RAGStrategyEvaluateResponse: {
			/**
			 * Strategy Name
			 * @description Name of the evaluated strategy
			 */
			strategy_name: string;
			/**
			 * Query
			 * @description The test query used
			 */
			query: string;
			/**
			 * Retrieval Metrics
			 * @description Retrieval quality metrics
			 */
			retrieval_metrics: {
				[key: string]: unknown;
			};
			/**
			 * Generation Metrics
			 * @description Generation quality metrics (if ground truth provided)
			 */
			generation_metrics?: {
				[key: string]: unknown;
			} | null;
			/**
			 * Latency Ms
			 * @description Total evaluation time in milliseconds
			 */
			latency_ms: number;
			/** @description Classified query type */
			query_type: components["schemas"]["QueryType"];
			/**
			 * Per Iteration Results
			 * @description Results from each iteration
			 */
			per_iteration_results?: {
				[key: string]: unknown;
			}[];
		};
		/**
		 * RAGStrategyInfo
		 * @description Information about a RAG strategy.
		 *
		 *     Attributes:
		 *         name: Strategy name (fast, balanced, thorough)
		 *         description: Human-readable description
		 *         config: Strategy configuration settings
		 *         use_cases: Recommended use cases
		 */
		RAGStrategyInfo: {
			/**
			 * Name
			 * @description Strategy name
			 */
			name: string;
			/**
			 * Description
			 * @description Human-readable description
			 */
			description: string;
			/**
			 * Config
			 * @description Strategy configuration settings
			 */
			config: {
				[key: string]: boolean;
			};
			/**
			 * Use Cases
			 * @description Recommended use cases
			 */
			use_cases?: string[];
			/**
			 * Estimated Latency Ms
			 * @description Estimated latency in milliseconds
			 * @default 0
			 */
			estimated_latency_ms: number;
		};
		/**
		 * RAGValidationErrorResponse
		 * @description Validation error response.
		 */
		RAGValidationErrorResponse: {
			/**
			 * Error
			 * @description Error details
			 */
			error: {
				[key: string]: unknown;
			};
			/**
			 * Validation Errors
			 * @description Validation errors
			 */
			validation_errors?: {
				[key: string]: unknown;
			}[];
		};
		/**
		 * ReadinessResponse
		 * @description Kubernetes readiness probe response.
		 */
		ReadinessResponse: {
			/** Ready */
			ready: boolean;
			/** Timestamp */
			timestamp: string;
			/** Checks */
			checks: {
				[key: string]: boolean;
			};
		};
		/**
		 * SearchResultItem
		 * @description Single search result item.
		 * @example {
		 *       "chunk_id": "123e4567-e89b-12d3-a456-426614174000",
		 *       "chunk_index": 0,
		 *       "content": "Sample chunk content...",
		 *       "job_id": "123e4567-e89b-12d3-a456-426614174001",
		 *       "metadata": {
		 *         "page": 1
		 *       },
		 *       "rank": 1,
		 *       "similarity_score": 0.95
		 *     }
		 */
		SearchResultItem: {
			/**
			 * Chunk Id
			 * @description Unique chunk identifier
			 */
			chunk_id: string;
			/**
			 * Job Id
			 * @description Parent job identifier
			 */
			job_id: string;
			/**
			 * Chunk Index
			 * @description Position within document
			 */
			chunk_index: number;
			/**
			 * Content
			 * @description Text content of the chunk
			 */
			content: string;
			/**
			 * Metadata
			 * @description Chunk metadata
			 */
			metadata?: {
				[key: string]: unknown;
			};
			/**
			 * Similarity Score
			 * @description Similarity score (0-1)
			 */
			similarity_score: number;
			/**
			 * Rank
			 * @description Result rank (1-based)
			 */
			rank: number;
		};
		/**
		 * SearchResultsResponse
		 * @description Response model for search results.
		 * @example {
		 *       "query_time_ms": 25.5,
		 *       "results": [],
		 *       "total": 0
		 *     }
		 */
		SearchResultsResponse: {
			/**
			 * Results
			 * @description Search results
			 */
			results?: components["schemas"]["SearchResultItem"][];
			/**
			 * Total
			 * @description Total number of results
			 */
			total: number;
			/**
			 * Query Time Ms
			 * @description Query execution time in milliseconds
			 */
			query_time_ms: number;
		};
		/**
		 * SemanticSearchRequest
		 * @description Request body for semantic search.
		 *
		 *     Performs cosine similarity search using a pre-computed embedding vector.
		 * @example {
		 *       "filters": {
		 *         "job_id": "123e4567-e89b-12d3-a456-426614174000"
		 *       },
		 *       "min_similarity": 0.7,
		 *       "query_embedding": [
		 *         0.1,
		 *         0.2,
		 *         0.3,
		 *         0.4
		 *       ],
		 *       "top_k": 10
		 *     }
		 */
		SemanticSearchRequest: {
			/**
			 * Query Embedding
			 * @description Query embedding vector (list of floats)
			 */
			query_embedding: number[];
			/**
			 * Top K
			 * @description Maximum number of results to return
			 * @default 10
			 */
			top_k: number;
			/**
			 * Min Similarity
			 * @description Minimum similarity threshold (0-1)
			 * @default 0.7
			 */
			min_similarity: number;
			/**
			 * Filters
			 * @description Optional filters (e.g., job_id)
			 */
			filters?: {
				[key: string]: unknown;
			};
		};
		/**
		 * TextSearchRequest
		 * @description Request body for text search.
		 *
		 *     Performs full-text search using PostgreSQL's tsvector/tsquery with BM25 ranking
		 *     and optional fuzzy trigram matching.
		 * @example {
		 *       "filters": {},
		 *       "highlight": true,
		 *       "language": "english",
		 *       "query": "machine learning architecture",
		 *       "top_k": 10,
		 *       "use_fuzzy": true
		 *     }
		 */
		TextSearchRequest: {
			/**
			 * Query
			 * @description Search query text
			 */
			query: string;
			/**
			 * Top K
			 * @description Maximum number of results to return
			 * @default 10
			 */
			top_k: number;
			/**
			 * Language
			 * @description Text search language configuration
			 * @default english
			 */
			language: string;
			/**
			 * Use Fuzzy
			 * @description Include fuzzy trigram matching
			 * @default true
			 */
			use_fuzzy: boolean;
			/**
			 * Highlight
			 * @description Include highlighted snippets with matched terms
			 * @default false
			 */
			highlight: boolean;
			/**
			 * Filters
			 * @description Optional filters (e.g., job_id)
			 */
			filters?: {
				[key: string]: unknown;
			};
		};
		/**
		 * TextSearchResultItem
		 * @description Text search result with additional fields.
		 * @example {
		 *       "chunk_id": "123e4567-e89b-12d3-a456-426614174000",
		 *       "chunk_index": 0,
		 *       "content": "Sample chunk content...",
		 *       "highlighted_content": "Sample <mark>chunk</mark> content...",
		 *       "job_id": "123e4567-e89b-12d3-a456-426614174001",
		 *       "matched_terms": [
		 *         "chunk"
		 *       ],
		 *       "metadata": {
		 *         "page": 1
		 *       },
		 *       "rank": 1,
		 *       "similarity_score": 0.85
		 *     }
		 */
		TextSearchResultItem: {
			/**
			 * Chunk Id
			 * @description Unique chunk identifier
			 */
			chunk_id: string;
			/**
			 * Job Id
			 * @description Parent job identifier
			 */
			job_id: string;
			/**
			 * Chunk Index
			 * @description Position within document
			 */
			chunk_index: number;
			/**
			 * Content
			 * @description Text content of the chunk
			 */
			content: string;
			/**
			 * Metadata
			 * @description Chunk metadata
			 */
			metadata?: {
				[key: string]: unknown;
			};
			/**
			 * Similarity Score
			 * @description Similarity score (0-1)
			 */
			similarity_score: number;
			/**
			 * Rank
			 * @description Result rank (1-based)
			 */
			rank: number;
			/**
			 * Highlighted Content
			 * @description Content with matched terms highlighted
			 */
			highlighted_content?: string | null;
			/**
			 * Matched Terms
			 * @description List of matched terms
			 */
			matched_terms?: string[] | null;
		};
		/**
		 * TextSearchResultsResponse
		 * @description Response model for text search results.
		 */
		TextSearchResultsResponse: {
			/**
			 * Results
			 * @description Search results
			 */
			results?: components["schemas"]["TextSearchResultItem"][];
			/**
			 * Total
			 * @description Total number of results
			 */
			total: number;
			/**
			 * Query Time Ms
			 * @description Query execution time in milliseconds
			 */
			query_time_ms: number;
		};
		/** ValidationError */
		ValidationError: {
			/** Location */
			loc: (string | number)[];
			/** Message */
			msg: string;
			/** Error Type */
			type: string;
			/** Input */
			input?: unknown;
			/** Context */
			ctx?: Record<string, never>;
		};
		/**
		 * VectorStoreHealthResponse
		 * @description Response model for vector store health check.
		 */
		VectorStoreHealthResponse: {
			/** Healthy */
			healthy: boolean;
			status: components["schemas"]["HealthStatus"];
			/** Message */
			message: string;
			/** Latency Ms */
			latency_ms?: number | null;
			/** Extensions */
			extensions?: {
				[key: string]: string;
			} | null;
			/** Pgvector Version */
			pgvector_version?: string | null;
			/** Pg Trgm Version */
			pg_trgm_version?: string | null;
			/** Missing Extensions */
			missing_extensions?: string[] | null;
			/** Timestamp */
			timestamp: string;
		};
		/**
		 * ChunkNotFoundResponse
		 * @description Error response when chunk is not found.
		 */
		src__api__routes__chunks__ChunkNotFoundResponse: {
			/**
			 * Detail
			 * @default Chunk not found
			 */
			detail: string;
		};
		/**
		 * ChunkNotFoundResponse
		 * @description Error response when reference chunk not found.
		 */
		src__api__routes__search__ChunkNotFoundResponse: {
			/**
			 * Detail
			 * @default Reference chunk not found
			 */
			detail: string;
		};
	};
	responses: never;
	parameters: never;
	requestBodies: never;
	headers: never;
	pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
	health_check_health_get: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ComprehensiveHealthResponse"];
				};
			};
		};
	};
	readiness_probe_health_ready_get: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ReadinessResponse"];
				};
			};
		};
	};
	liveness_probe_health_live_get: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["LivenessResponse"];
				};
			};
		};
	};
	get_queue_health_health_queue_get: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": {
						[key: string]: unknown;
					};
				};
			};
		};
	};
	get_metrics_metrics_get: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": unknown;
				};
			};
		};
	};
	get_openapi_yaml_api_v1_openapi_yaml_get: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": unknown;
				};
			};
		};
	};
	list_jobs_api_v1_jobs_get: {
		parameters: {
			query?: {
				page?: number;
				limit?: number;
				status?: string | null;
				source_type?: string | null;
				sort_by?: string;
				sort_order?: string;
			};
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": {
						[key: string]: unknown;
					};
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	create_job_api_v1_jobs_post: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": {
					[key: string]: unknown;
				};
			};
		};
		responses: {
			/** @description Successful Response */
			202: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": {
						[key: string]: unknown;
					};
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	get_job_api_v1_jobs__job_id__get: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				job_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": {
						[key: string]: unknown;
					};
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	cancel_job_api_v1_jobs__job_id__delete: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				job_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	retry_job_api_v1_jobs__job_id__retry_post: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				job_id: string;
			};
			cookie?: never;
		};
		requestBody?: {
			content: {
				"application/json": {
					[key: string]: unknown;
				} | null;
			};
		};
		responses: {
			/** @description Successful Response */
			202: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": {
						[key: string]: unknown;
					};
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	get_job_result_api_v1_jobs__job_id__result_get: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				job_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": {
						[key: string]: unknown;
					};
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	upload_files_api_v1_upload_post: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"multipart/form-data": {
					/** @description Files to upload */
					files: File[];
					/** @description Priority level */
					priority?: "low" | "normal" | "high";
					/** @description Pipeline configuration UUID */
					pipeline_id?: string;
					/** @description Destination UUIDs */
					destination_ids?: string;
					/** @description Custom metadata as JSON string */
					metadata?: string;
				};
			};
		};
		responses: {
			/** @description Successful Response */
			202: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": {
						data: {
							jobs: Array<{
								id: string;
								status: string;
								source_type: string;
								source_uri: string;
								file_name?: string;
								file_size?: number;
								mime_type?: string | null;
								priority: number;
								created_at: string;
							}>;
							total: number;
						};
						meta: {
							request_id: string;
							timestamp: string;
							api_version: string;
						};
					};
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	ingest_from_url_api_v1_upload_url_post: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": {
					[key: string]: unknown;
				};
			};
		};
		responses: {
			/** @description Successful Response */
			202: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": {
						[key: string]: unknown;
					};
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	list_pipelines_api_v1_pipelines_get: {
		parameters: {
			query?: {
				page?: number;
				limit?: number;
			};
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": {
						[key: string]: unknown;
					};
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	create_pipeline_api_v1_pipelines_post: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": {
					[key: string]: unknown;
				};
			};
		};
		responses: {
			/** @description Successful Response */
			201: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": {
						[key: string]: unknown;
					};
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	get_pipeline_api_v1_pipelines__pipeline_id__get: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				pipeline_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": {
						[key: string]: unknown;
					};
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	update_pipeline_api_v1_pipelines__pipeline_id__put: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				pipeline_id: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": {
					[key: string]: unknown;
				};
			};
		};
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": {
						[key: string]: unknown;
					};
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	delete_pipeline_api_v1_pipelines__pipeline_id__delete: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				pipeline_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	list_sources_api_v1_sources_get: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": {
						[key: string]: unknown;
					};
				};
			};
		};
	};
	list_destinations_api_v1_destinations_get: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": {
						[key: string]: unknown;
					};
				};
			};
		};
	};
	login_api_v1_auth_login_post: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": {
					[key: string]: unknown;
				};
			};
		};
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": {
						[key: string]: unknown;
					};
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	refresh_token_api_v1_auth_refresh_post: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": {
					[key: string]: unknown;
				};
			};
		};
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": {
						[key: string]: unknown;
					};
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	list_api_keys_api_v1_auth_api_keys_get: {
		parameters: {
			query?: {
				page?: number;
				limit?: number;
			};
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": {
						[key: string]: unknown;
					};
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	create_api_key_api_v1_auth_api_keys_post: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": {
					[key: string]: unknown;
				};
			};
		};
		responses: {
			/** @description Successful Response */
			201: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": {
						[key: string]: unknown;
					};
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	revoke_api_key_api_v1_auth_api_keys__key_id__delete: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				key_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	list_webhooks_api_v1_webhooks_get: {
		parameters: {
			query?: {
				user_id?: string | null;
				page?: number;
				limit?: number;
			};
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": {
						[key: string]: unknown;
					};
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	create_webhook_api_v1_webhooks_post: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": {
					[key: string]: unknown;
				};
			};
		};
		responses: {
			/** @description Successful Response */
			201: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": {
						[key: string]: unknown;
					};
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	delete_webhook_api_v1_webhooks__webhook_id__delete: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				webhook_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	list_webhook_deliveries_api_v1_webhooks__webhook_id__deliveries_get: {
		parameters: {
			query?: {
				status?: string | null;
				page?: number;
				limit?: number;
			};
			header?: never;
			path: {
				webhook_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": {
						[key: string]: unknown;
					};
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	query_audit_logs_api_v1_audit_logs_get: {
		parameters: {
			query?: {
				page?: number;
				limit?: number;
				user_id?: string | null;
				action?: string | null;
				resource_type?: string | null;
				start_date?: string | null;
				end_date?: string | null;
			};
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": {
						[key: string]: unknown;
					};
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	vector_store_health_health_vector_get: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["VectorStoreHealthResponse"];
				};
			};
		};
	};
	detailed_component_health_health_detailed__component__get: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				component: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": {
						[key: string]: unknown;
					};
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	list_chunks_api_v1_jobs__job_id__chunks_get: {
		parameters: {
			query?: {
				/** @description Maximum number of chunks to return */
				limit?: number;
				/** @description Number of chunks to skip */
				offset?: number;
				/** @description Include vector embedding in response (performance impact) */
				include_embedding?: boolean;
			};
			header?: never;
			path: {
				job_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["DocumentChunkListResponse"];
				};
			};
			/** @description Invalid UUID format */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
			/** @description Job not found */
			404: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["JobNotFoundResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
			/** @description Rate limit exceeded */
			429: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	get_chunk_api_v1_jobs__job_id__chunks__chunk_id__get: {
		parameters: {
			query?: {
				/** @description Include vector embedding in response */
				include_embedding?: boolean;
			};
			header?: never;
			path: {
				job_id: string;
				chunk_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["DocumentChunkResponse"];
				};
			};
			/** @description Chunk doesn't belong to job */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ChunkJobMismatchResponse"];
				};
			};
			/** @description Chunk not found */
			404: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["src__api__routes__chunks__ChunkNotFoundResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
			/** @description Rate limit exceeded */
			429: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	semantic_search_api_v1_search_semantic_post: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["SemanticSearchRequest"];
			};
		};
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["SearchResultsResponse"];
				};
			};
			/** @description Invalid embedding vector */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["InvalidEmbeddingResponse"];
				};
			};
			/** @description Validation error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
			/** @description Rate limit exceeded */
			429: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	text_search_api_v1_search_text_post: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["TextSearchRequest"];
			};
		};
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["TextSearchResultsResponse"];
				};
			};
			/** @description Invalid search query */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["InvalidQueryResponse"];
				};
			};
			/** @description Validation error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
			/** @description Rate limit exceeded */
			429: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	hybrid_search_api_v1_search_hybrid_post: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["HybridSearchRequest"];
			};
		};
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HybridSearchResultsResponse"];
				};
			};
			/** @description Invalid search query */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["InvalidQueryResponse"];
				};
			};
			/** @description Validation error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
			/** @description Rate limit exceeded */
			429: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	find_similar_chunks_api_v1_search_similar__chunk_id__get: {
		parameters: {
			query?: {
				/** @description Maximum number of results */
				top_k?: number;
				/** @description Exclude the reference chunk from results */
				exclude_self?: boolean;
			};
			header?: never;
			path: {
				chunk_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["SearchResultsResponse"];
				};
			};
			/** @description Invalid UUID format */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
			/** @description Reference chunk not found */
			404: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["src__api__routes__search__ChunkNotFoundResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
			/** @description Rate limit exceeded */
			429: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	rag_query_api_v1_rag_query_post: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["RAGQueryRequest"];
			};
		};
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["RAGQueryResponse"];
				};
			};
			/** @description Invalid request parameters */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["RAGValidationErrorResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
			/** @description RAG processing failed */
			500: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["RAGQueryErrorResponse"];
				};
			};
		};
	};
	list_strategies_api_v1_rag_strategies_get: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["RAGStrategiesResponse"];
				};
			};
		};
	};
	evaluate_strategy_api_v1_rag_strategies__name__evaluate_post: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				name: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["RAGStrategyEvaluateRequest"];
			};
		};
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["RAGStrategyEvaluateResponse"];
				};
			};
			/** @description Invalid request parameters */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["RAGValidationErrorResponse"];
				};
			};
			/** @description Strategy not found */
			404: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
			/** @description Evaluation failed */
			500: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["RAGQueryErrorResponse"];
				};
			};
		};
	};
	get_metrics_api_v1_rag_metrics_get: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["RAGMetricsResponse"];
				};
			};
		};
	};
	run_benchmark_api_v1_rag_evaluate_post: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["RAGBenchmarkRequest"];
			};
		};
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["RAGBenchmarkResponse"];
				};
			};
			/** @description Invalid request parameters */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["RAGValidationErrorResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
			/** @description Benchmark failed */
			500: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["RAGQueryErrorResponse"];
				};
			};
		};
	};
}
